# 跨域问题完整解决方案

## 前言

在开发 RadarLive-CN 项目时，我遇到了典型的跨域问题：前端运行在 `http://localhost:3000`，后端运行在 `http://localhost:8000`，浏览器阻止跨域请求。本文分享完整的跨域解决方案和最佳实践。

## 什么是跨域

跨域是指浏览器阻止从一个域名的网页向另一个域名的服务器发起请求。这是浏览器的同源策略（Same-Origin Policy）导致的。

### 同源策略

同源是指协议、域名、端口都相同。以下情况属于跨域：

- `http://localhost:3000` → `http://localhost:8000` ❌
- `https://example.com` → `http://example.com` ❌
- `http://example.com:3000` → `http://example.com:8000` ❌

## 解决方案：CORS

CORS（Cross-Origin Resource Sharing）是 W3C 标准，允许服务器声明哪些源可以访问资源。

### FastAPI CORS 配置

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import os

app = FastAPI(title="Radar Live CN API", version="1.0.0")

# CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("CORS_ORIGINS", "*").split(","),  # 允许的源
    allow_credentials=True,                                    # 允许携带凭证
    allow_methods=["*"],                                       # 允许所有HTTP方法
    allow_headers=["*"],                                       # 允许所有请求头
)
```

### 环境变量配置

**开发环境**（`.env` 或 `docker-compose.yml`）：

```yaml
# 允许所有源
CORS_ORIGINS: "*"
```

**生产环境**：

```yaml
# 只允许特定域名
CORS_ORIGINS: "https://yourdomain.com,https://www.yourdomain.com"
```

## 前端配置

### Axios 实例配置

```javascript
import axios from 'axios'

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api'

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 60000,
  headers: {
    'Content-Type': 'application/json'
  }
})
```

### 请求拦截器（自动添加 Token）

```javascript
apiClient.interceptors.request.use(
  config => {
    const token = localStorage.getItem('auth_token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => Promise.reject(error)
)
```

### 响应拦截器（Token 刷新）

```javascript
apiClient.interceptors.response.use(
  response => response.data,
  async error => {
    // 401 错误时尝试刷新 Token
    const originalRequest = error.config
    if (error.response?.status === 401 && !originalRequest._retry) {
      const refreshToken = localStorage.getItem('refresh_token')
      if (refreshToken) {
        try {
          const resp = await axios.post(`${API_BASE_URL}/refresh`, { 
            refresh_token: refreshToken 
          })
          const newAccess = resp.data?.access_token
          localStorage.setItem('auth_token', newAccess)
          originalRequest.headers.Authorization = `Bearer ${newAccess}`
          return apiClient(originalRequest)
        } catch (refreshErr) {
          // 刷新失败，跳转登录
          localStorage.clear()
          window.location.reload()
        }
      }
    }
    return Promise.reject(error)
  }
)
```

## 不同场景的配置

### 1. 开发环境

```python
# 允许所有源，方便开发调试
allow_origins=["*"]
```

### 2. 生产环境

```python
# 只允许特定域名，提高安全性
allow_origins=[
    "https://yourdomain.com",
    "https://www.yourdomain.com"
]
```

### 3. 携带凭证

```python
# 允许携带 Cookie 等凭证
allow_credentials=True
```

### 4. 预检请求

对于复杂请求（如 PUT、DELETE），浏览器会先发送 OPTIONS 预检请求。FastAPI 的 CORS 中间件会自动处理。

## 常见问题

### 1. 预检请求失败

**问题**：OPTIONS 请求返回 405 或 404

**解决**：确保 CORS 中间件正确配置，允许 OPTIONS 方法

### 2. 凭证无法携带

**问题**：设置了 `allow_credentials=True`，但 Cookie 无法携带

**解决**：
- 确保 `allow_origins` 不能是 `["*"]`，必须指定具体域名
- 前端请求需要设置 `withCredentials: true`

### 3. 自定义请求头被阻止

**问题**：自定义请求头（如 `X-Custom-Header`）被阻止

**解决**：在 `allow_headers` 中添加自定义请求头

## 安全最佳实践

### 1. 生产环境限制源

```python
# 生产环境：只允许特定域名
allow_origins=[
    "https://yourdomain.com",
    "https://www.yourdomain.com"
]
```

### 2. 限制 HTTP 方法

```python
# 只允许必要的 HTTP 方法
allow_methods=["GET", "POST", "PUT", "DELETE"]
```

### 3. 限制请求头

```python
# 只允许必要的请求头
allow_headers=["Content-Type", "Authorization"]
```

## 总结

跨域问题的完整解决方案：

- ✅ 使用 CORS 中间件配置允许的源
- ✅ 开发环境允许所有源，生产环境限制特定域名
- ✅ 合理配置凭证、方法、请求头
- ✅ 前端正确配置请求拦截器和响应拦截器

通过合理的 CORS 配置，我们可以安全地解决跨域问题。

---

*本文基于 RadarLive-CN 项目的实际开发经验总结*

