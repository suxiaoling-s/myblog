# 防抖节流在前端开发中的应用

## 前言

在开发 RadarLive-CN 项目时，我深入学习了防抖（debounce）和节流（throttle）的使用。通过合理应用这些技巧，显著提升了用户体验和性能。本文分享我在实际项目中的使用经验和最佳实践。

## 什么是防抖和节流

### 防抖（Debounce）

防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。

**适用场景**：
- 搜索框输入
- 窗口 resize
- 表单验证

### 节流（Throttle）

节流是指规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

**适用场景**：
- 滚动事件
- 鼠标移动
- 频繁点击

## 项目中的实际应用

### 1. 站点切换防抖

```javascript
let stationChangeTimer = null

const scheduleStationChange = (nextStation) => {
  // 清除之前的定时器
  clearStationChangeTimer()
  // 取消之前的请求
  cancelStationRequests()
  
  // 设置新的定时器
  stationChangeTimer = setTimeout(() => {
    stationChangeTimer = null
    runStationChange(nextStation)  // 执行切换
  }, 300)  // 300ms 防抖延迟
}

const clearStationChangeTimer = () => {
  if (stationChangeTimer) {
    clearTimeout(stationChangeTimer)
    stationChangeTimer = null
  }
}
```

**效果**：
- 用户快速切换站点时，只执行最后一次切换
- 减少不必要的 API 请求
- 提升用户体验

### 2. 区域切换防抖

```javascript
let regionChangeTimer = null

const scheduleRegionChange = (nextRegion) => {
  clearRegionChangeTimer()
  regionChangeTimer = setTimeout(() => {
    regionChangeTimer = null
    runRegionChange(nextRegion)
  }, 300)
}
```

### 3. 请求取消机制

```javascript
const activeStationController = ref(null)

const cancelStationRequests = () => {
  if (activeStationController.value) {
    activeStationController.value.abort()  // 取消请求
    activeStationController.value = null
  }
}

const runStationChange = async (nextStation) => {
  const controller = new AbortController()
  activeStationController.value = controller
  
  try {
    await onStationChange(nextStation, requestId, controller)
  } catch (error) {
    if (!isAbortError(error)) {
      console.error('站点切换失败:', error)
    }
  }
}
```

## 通用防抖函数实现

```javascript
function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// 使用
const handleSearch = debounce((query) => {
  // 执行搜索
  searchAPI(query)
}, 300)
```

## 通用节流函数实现

```javascript
function throttle(func, limit) {
  let inThrottle
  return function executedFunction(...args) {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// 使用
const handleScroll = throttle(() => {
  // 处理滚动
  updateScrollPosition()
}, 100)
```

## 使用场景总结

### 防抖适用场景

1. **搜索框输入**：用户输入停止后才发送请求
2. **表单验证**：用户输入停止后才验证
3. **窗口 resize**：窗口大小调整停止后才计算布局
4. **按钮点击**：防止重复提交

### 节流适用场景

1. **滚动事件**：限制滚动处理频率
2. **鼠标移动**：限制鼠标移动处理频率
3. **频繁点击**：限制点击处理频率
4. **实时数据更新**：限制更新频率

## 实践心得

### 1. 延迟时间的选择

- **防抖**：通常 200-500ms，根据用户操作习惯调整
- **节流**：通常 100-300ms，根据实际需求调整

### 2. 结合请求取消

- 使用 `AbortController` 取消过时请求
- 避免资源浪费
- 提升用户体验

### 3. 清理机制

- 组件卸载时清理定时器
- 避免内存泄漏
- 使用 `onUnmounted` 钩子

### 4. 性能监控

- 监控防抖/节流效果
- 根据实际数据调整参数
- 持续优化

## 总结

防抖和节流是前端性能优化的重要技巧：

- ✅ 防抖：延迟执行，适合搜索、验证等场景
- ✅ 节流：限制频率，适合滚动、移动等场景
- ✅ 结合请求取消，提升用户体验
- ✅ 合理选择延迟时间，平衡性能和体验

---

*本文基于 RadarLive-CN 项目的实际开发经验总结*

