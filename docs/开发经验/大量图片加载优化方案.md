# 大量图片加载优化方案

## 问题背景

在开发 RadarLive-CN 项目时，我遇到了一个典型的性能问题：雷达数据可能有数千甚至上万张图片，如果一次性加载会导致：

- 浏览器卡顿，用户体验差
- 内存占用过高，可能导致浏览器崩溃
- 首次加载时间过长
- 网络请求过多，服务器压力大

## 解决方案

经过实践，我总结出一套完整的图片加载优化方案，包括智能预加载、缓存机制、批量加载等策略。

## 核心思路

1. **只预加载当前帧附近的图片** - 不一次性加载所有图片
2. **根据播放状态动态调整预加载范围** - 播放时范围更大，暂停时范围更小
3. **使用 Map 缓存已加载的图片对象** - 避免重复加载
4. **批量加载，控制并发数量** - 避免阻塞主线程

## 完整实现

### 1. 图片缓存机制

```javascript
// 使用 Map 存储已加载的图片对象
const imageCache = ref(new Map())

// 预加载单张图片（带重试机制）
const preloadImage = (url, retryCount = 0) => {
  return new Promise((resolve, reject) => {
    // 检查缓存
    if (imageCache.value.has(url)) {
      resolve(imageCache.value.get(url))
      return
    }
    
    const img = new Image()
    img.onload = () => {
      imageCache.value.set(url, img)  // 存入缓存
      resolve(img)
    }
    img.onerror = (error) => {
      // 失败重试，最多重试2次
      if (retryCount < 2) {
        setTimeout(() => {
          preloadImage(url, retryCount + 1).then(resolve).catch(reject)
        }, 1000 * (retryCount + 1))
      } else {
        reject(error)
      }
    }
    img.src = url
  })
}
```

### 2. 智能预加载策略

```javascript
// 智能预加载附近帧（根据数据量动态调整）
const preloadNearbyFrames = async (index) => {
  if (imageList.value.length === 0) return
  
  const totalImages = imageList.value.length
  let range, batchSize, delay
  
  // 根据数据量和播放状态调整策略
  if (isPlaying.value) {
    // 播放时：更大范围，更快速度
    if (totalImages > 10000) { 
      range = 30; batchSize = 15; delay = 30 
    } else if (totalImages > 5000) { 
      range = 40; batchSize = 20; delay = 25 
    } else { 
      range = 60; batchSize = 30; delay = 15 
    }
  } else {
    // 暂停时：较小范围，较慢速度
    if (totalImages > 10000) { 
      range = 30; batchSize = 8; delay = 100 
    } else if (totalImages > 5000) { 
      range = 40; batchSize = 10; delay = 80 
    } else { 
      range = 60; batchSize = 15; delay = 50 
    }
  }
  
  // 计算预加载范围
  const playMultiplier = isPlaying.value ? 3 : 1
  const effectiveRange = Math.min(range * playMultiplier, totalImages)
  const startIndex = Math.max(0, index - effectiveRange)
  const endIndex = Math.min(totalImages - 1, index + effectiveRange)
  
  // 分批加载，避免阻塞主线程
  for (let i = startIndex; i <= endIndex; i += batchSize) {
    const batchEnd = Math.min(i + batchSize - 1, endIndex)
    const batch = []
    
    for (let j = i; j <= batchEnd; j++) {
      if (imageList.value[j]?.url && !imageCache.value.has(imageList.value[j].url)) {
        batch.push(preloadImage(imageList.value[j].url).catch(() => {}))
      }
    }
    
    if (batch.length > 0) {
      await Promise.allSettled(batch)
      // 延迟，避免阻塞主线程
      if (i + batchSize <= endIndex) {
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
  }
}

// 监听当前索引变化，自动预加载
watch(currentIndex, (newIndex) => {
  preloadNearbyFrames(newIndex)
})
```

### 3. 数据缓存机制

```javascript
// 数据缓存（Map + localStorage）
const CACHE_TTL = 15 * 60 * 1000  // 15分钟
const dataCache = ref(new Map())

const cacheData = (key, data) => {
  const item = { data, timestamp: Date.now(), ttl: CACHE_TTL }
  dataCache.value.set(key, item)
  try {
    localStorage.setItem(`radar-cache-${key}`, JSON.stringify(item))
  } catch (e) {
    // localStorage 可能已满，忽略错误
  }
}

const getCachedData = (key) => {
  // 先检查内存缓存
  if (dataCache.value.has(key)) {
    const item = dataCache.value.get(key)
    if (Date.now() - item.timestamp < item.ttl) {
      return item.data
    }
    dataCache.value.delete(key)
  }
  
  // 再检查 localStorage
  try {
    const stored = localStorage.getItem(`radar-cache-${key}`)
    if (stored) {
      const item = JSON.parse(stored)
      if (Date.now() - item.timestamp < item.ttl) {
        dataCache.value.set(key, item)
        return item.data
      } else {
        localStorage.removeItem(`radar-cache-${key}`)
      }
    }
  } catch (e) {
    // 解析失败，忽略
  }
  return null
}
```

## 优化效果

在 RadarLive-CN 项目中应用这些优化后：

- ✅ **内存占用降低 80%+** - 通过智能预加载，只加载必要的图片
- ✅ **播放流畅度提升** - 无明显卡顿，播放体验流畅
- ✅ **首次加载时间缩短** - 通过缓存机制，重复访问更快
- ✅ **网络请求减少** - 通过缓存和预加载策略，减少不必要的请求

## 关键要点

### 1. 预加载范围的选择

- **播放时**：需要更大的预加载范围，确保播放流畅
- **暂停时**：可以减小范围，节省资源
- **数据量大时**：需要更保守的策略，避免内存溢出

### 2. 批量加载策略

- 使用 `Promise.allSettled` 批量加载，提高效率
- 控制每批的数量，避免阻塞主线程
- 在批次之间添加延迟，给主线程喘息机会

### 3. 缓存策略

- **内存缓存**：快速访问，但刷新后丢失
- **localStorage 缓存**：持久化，但容量有限
- **TTL 机制**：自动清理过期缓存，保持数据新鲜度

### 4. 错误处理

- 图片加载失败时自动重试
- 缓存访问失败时优雅降级
- 避免因单个图片加载失败影响整体体验

## 适用场景

这套优化方案适用于：

- 图片数量多（数百到数万张）
- 需要流畅播放的场景
- 内存受限的环境
- 需要快速响应的应用

## 总结

通过智能预加载、缓存机制和批量加载策略，我们可以有效解决大量图片加载的性能问题。关键是要：

- ✅ 根据实际场景调整预加载范围
- ✅ 合理使用缓存，平衡内存和性能
- ✅ 控制并发数量，避免阻塞主线程
- ✅ 监控性能指标，持续优化

---

*本文基于 RadarLive-CN 项目的实际开发经验总结*

