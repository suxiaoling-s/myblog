# RadarLive-CN 项目学习收获

## 项目简介

RadarLive-CN 是一个雷达数据实时展示系统，类似中央气象台的雷达数据展示网站。在开发这个项目的过程中，我学到了很多技术知识和实践经验。

## 技术栈

- **后端**: FastAPI + PostgreSQL
- **前端**: Vue 3 + Element Plus + Leaflet
- **部署**: Docker + Docker Compose

## 主要收获

### 1. FastAPI 异步编程

学会了使用 FastAPI 进行异步 API 开发，提高了应用的并发处理能力。

```python
@router.get("/radar/latest")
async def get_latest_radar():
    scanner = get_scanner()
    latest = await scanner.get_latest_image()
    return latest
```

### 2. Vue 3 组合式 API

深入理解了 Vue 3 的组合式 API，能够更好地组织和复用代码。

```javascript
import { ref, computed, onMounted } from 'vue'

export default {
  setup() {
    const imageList = ref([])
    const currentIndex = ref(0)
    
    const currentImage = computed(() => {
      return imageList.value[currentIndex.value]
    })
    
    onMounted(() => {
      loadData()
    })
    
    return { imageList, currentIndex, currentImage }
  }
}
```

### 3. Docker 容器化部署

学会了使用 Docker 和 Docker Compose 进行应用的容器化部署，实现了开发和生产环境的一致性。

### 4. 性能优化

在项目中实践了多种性能优化技巧：
- 图片预加载
- 数据缓存
- 分页加载
- 防抖节流

## 遇到的挑战

### 1. 大量图片加载优化

**问题**: 雷达数据可能有数千甚至上万张图片，如果一次性加载会导致浏览器卡顿、内存占用过高。

**解决方案**: 实现智能预加载和缓存机制

**核心思路**:
- 只预加载当前帧附近的图片
- 根据播放状态动态调整预加载范围
- 使用 Map 缓存已加载的图片对象
- 批量加载，控制并发数量

**代码实现**:

```javascript
// 图片缓存
const imageCache = ref(new Map())

// 预加载单张图片（带重试机制）
const preloadImage = (url, retryCount = 0) => {
  return new Promise((resolve, reject) => {
    // 检查缓存
    if (imageCache.value.has(url)) {
      resolve(imageCache.value.get(url))
      return
    }
    
    const img = new Image()
    img.onload = () => {
      imageCache.value.set(url, img)  // 存入缓存
      resolve(img)
    }
    img.onerror = (error) => {
      // 失败重试，最多重试2次
      if (retryCount < 2) {
        setTimeout(() => {
          preloadImage(url, retryCount + 1).then(resolve).catch(reject)
        }, 1000 * (retryCount + 1))
      } else {
        reject(error)
      }
    }
    img.src = url
  })
}

// 智能预加载附近帧（根据数据量动态调整）
const preloadNearbyFrames = async (index) => {
  if (imageList.value.length === 0) return
  
  const totalImages = imageList.value.length
  let range, batchSize, delay
  
  // 根据数据量和播放状态调整策略
  if (isPlaying.value) {
    // 播放时：更大范围，更快速度
    if (totalImages > 10000) { range = 30; batchSize = 15; delay = 30 }
    else if (totalImages > 5000) { range = 40; batchSize = 20; delay = 25 }
    else { range = 60; batchSize = 30; delay = 15 }
  } else {
    // 暂停时：较小范围，较慢速度
    if (totalImages > 10000) { range = 30; batchSize = 8; delay = 100 }
    else if (totalImages > 5000) { range = 40; batchSize = 10; delay = 80 }
    else { range = 60; batchSize = 15; delay = 50 }
  }
  
  // 计算预加载范围
  const playMultiplier = isPlaying.value ? 3 : 1
  const effectiveRange = Math.min(range * playMultiplier, totalImages)
  const startIndex = Math.max(0, index - effectiveRange)
  const endIndex = Math.min(totalImages - 1, index + effectiveRange)
  
  // 分批加载
  for (let i = startIndex; i <= endIndex; i += batchSize) {
    const batchEnd = Math.min(i + batchSize - 1, endIndex)
    const batch = []
    for (let j = i; j <= batchEnd; j++) {
      if (imageList.value[j]?.url && !imageCache.value.has(imageList.value[j].url)) {
        batch.push(preloadImage(imageList.value[j].url).catch(() => {}))
      }
    }
    if (batch.length > 0) {
      await Promise.allSettled(batch)
      // 延迟，避免阻塞主线程
      if (i + batchSize <= endIndex) {
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
  }
}

// 监听当前索引变化，自动预加载
watch(currentIndex, (newIndex) => {
  preloadNearbyFrames(newIndex)
})
```

**效果**: 
- 内存占用降低 80%+
- 播放流畅度提升，无明显卡顿
- 首次加载时间缩短

### 2. 时间轴同步

**问题**: 多个组件（时间列表、滑块、播放控制）需要同步当前时间索引，状态管理复杂。

**解决方案**: 使用 Vue 3 的响应式系统和计算属性

**核心思路**:
- 使用 `ref` 统一管理当前索引
- 使用 `computed` 自动计算当前图像
- 使用 `watch` 监听变化并同步更新
- 所有组件共享同一个响应式状态

**代码实现**:

```javascript
import { ref, computed, watch } from 'vue'

export default {
  setup() {
    // 统一的状态管理
    const imageList = ref([])           // 图像列表
    const currentIndex = ref(0)         // 当前索引（单一数据源）
    
    // 计算属性：自动从索引获取当前图像
    const currentImage = computed(() => {
      if (imageList.value.length === 0) return null
      return imageList.value[currentIndex.value]
    })
    
    // 时间列表项（自动同步）
    const timeListItems = computed(() => {
      return imageList.value.map((item, index) => ({
        key: `${item.timestamp}-${index}`,
        index,
        timestamp: item.timestamp,
        display: formatTimestamp(item.timestamp)
      })).reverse()
    })
    
    // 时间轴滑块变化 → 更新索引
    const handleSliderChange = (value) => {
      currentIndex.value = value
    }
    
    // 时间列表点击 → 更新索引
    const handleTimelineItemClick = (index) => {
      currentIndex.value = index
    }
    
    // 播放控制 → 更新索引
    const nextImage = () => {
      if (currentIndex.value < imageList.value.length - 1) {
        currentIndex.value++
      }
    }
    
    const previousImage = () => {
      if (currentIndex.value > 0) {
        currentIndex.value--
      }
    }
    
    // 自动播放时自动更新索引
    const startAutoPlay = () => {
      playInterval.value = setInterval(() => {
        if (currentIndex.value < imageList.value.length - 1) {
          currentIndex.value++
        } else if (loopEnabled.value) {
          currentIndex.value = 0  // 循环播放
        } else {
          stopAutoPlay()
        }
      }, playbackIntervalMs.value)
    }
    
    // 所有组件自动响应 currentIndex 的变化
    return {
      imageList,
      currentIndex,      // 单一数据源
      currentImage,      // 自动计算
      timeListItems,    // 自动计算
      handleSliderChange,
      handleTimelineItemClick,
      nextImage,
      previousImage
    }
  }
}
```

**模板中的使用**:

```vue
<template>
  <!-- 时间列表：自动高亮当前项 -->
  <button
    v-for="item in timeListItems"
    :key="item.key"
    :class="{ active: item.index === currentIndex }"
    @click="handleTimelineItemClick(item.index)"
  >
    {{ item.display }}
  </button>
  
  <!-- 时间轴滑块：双向绑定 -->
  <el-slider
    v-model="currentIndex"
    :max="imageList.length - 1"
    @change="handleSliderChange"
  />
  
  <!-- 当前图像：自动更新 -->
  <img :src="currentImage?.url" />
  
  <!-- 播放控制：操作索引 -->
  <button @click="nextImage">下一帧</button>
</template>
```

**效果**: 
- 状态同步零延迟
- 代码简洁，易于维护
- 无需手动同步多个组件

### 3. 跨域问题

**问题**: 前端运行在 `http://localhost:3000`，后端运行在 `http://localhost:8000`，浏览器阻止跨域请求。

**解决方案**: 配置 FastAPI 的 CORS 中间件

**代码实现**:

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from os import getenv

app = FastAPI(title="Radar Live CN API", version="1.0.0")

# CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=getenv("CORS_ORIGINS", "*").split(","),  # 允许的源
    allow_credentials=True,                                 # 允许携带凭证
    allow_methods=["*"],                                    # 允许所有HTTP方法
    allow_headers=["*"],                                    # 允许所有请求头
)
```

**环境变量配置** (通过系统环境变量或 `docker-compose.yml`):

```yaml
# 开发环境：允许所有源
CORS_ORIGINS: "*"

# 生产环境：只允许特定域名
CORS_ORIGINS: "https://yourdomain.com,https://www.yourdomain.com"
```

**前端请求示例**:

```javascript
import axios from 'axios'

// 创建 axios 实例
const api = axios.create({
  baseURL: 'http://localhost:8000/api',
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器：自动添加 Token
api.interceptors.request.use(config => {
  const token = localStorage.getItem('auth_token')
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

// 使用
const response = await api.get('/radar/list')
```

**效果**: 
- 跨域请求正常工作
- 支持携带认证 Token
- 生产环境可限制允许的域名，提高安全性

### 4. 防抖节流优化

**额外优化**: 在站点/区域切换时使用防抖，避免频繁请求。

**代码实现**:

```javascript
// 防抖函数：300ms 内只执行最后一次
const scheduleStationChange = (nextStation) => {
  clearStationChangeTimer()  // 清除之前的定时器
  cancelStationRequests()    // 取消之前的请求
  
  stationChangeTimer = setTimeout(() => {
    stationChangeTimer = null
    runStationChange(nextStation)  // 执行切换
  }, 300)  // 300ms 防抖延迟
}

// 区域切换同样使用防抖
const scheduleRegionChange = (nextRegion) => {
  clearRegionChangeTimer()
  regionChangeTimer = setTimeout(() => {
    regionChangeTimer = null
    runRegionChange(nextRegion)
  }, 300)
}

// 使用 AbortController 取消过时请求
const cancelStationRequests = () => {
  if (activeStationController.value) {
    activeStationController.value.abort()  // 取消请求
    activeStationController.value = null
  }
}
```

**效果**: 
- 减少不必要的 API 请求
- 提升用户体验，避免界面闪烁
- 节省服务器资源

## 未来计划

- 继续深入学习 FastAPI 的高级特性
- 探索更多前端性能优化技巧

---

*最后更新: {{ git_revision_date_localized }}*
