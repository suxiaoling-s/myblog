# 前端架构详解

## 概述

前端采用 Vue.js 3 组合式 API 构建，提供现代化的用户界面。主要功能包括：
- 用户登录/注册
- 雷达数据实时展示
- 时间轴播放控制
- 区域和站点筛选
- 图片缩放和预览

## 核心组件

### 路由配置 (`router/index.js`)

使用 Vue Router 4 进行路由管理，配置了认证守卫和路由重定向。

**路由定义**:

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import Login from '../Login.vue'
import Register from '../Register.vue'
import RadarView from '../RadarView.vue'

const routes = [
  {
    path: '/login',
    name: 'Login',
    component: Login,
    meta: { public: true }
  },
  {
    path: '/register',
    name: 'Register',
    component: Register,
    meta: { public: true }
  },
  {
    path: '/radar/mosaic',
    name: 'RadarMosaic',
    component: RadarView,
    props: { viewMode: 'mosaic', allowModeSwitch: false },
    meta: { requiresAuth: true }
  },
  {
    path: '/radar/single',
    name: 'RadarSingle',
    component: RadarView,
    props: { viewMode: 'single', allowModeSwitch: false },
    meta: { requiresAuth: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})
```

**路由守卫**:

```javascript
router.beforeEach((to, from, next) => {
  const token = localStorage.getItem('auth_token')
  if (to.meta.requiresAuth && !token) {
    next({ path: '/login', query: { redirect: to.fullPath } })
    return
  }
  if (to.path === '/login' && token) {
    next({ path: '/' })
    return
  }
  next()
})
```

### 主应用组件 (`App.vue`)

根组件，作为应用的入口容器，负责渲染路由视图。

```vue
<template>
  <div id="app">
    <router-view />
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>

<style>
/* 全局样式可按需扩展 */
</style>
```

**说明**: 这是一个简单的容器组件，主要作用是：
- 提供应用根节点
- 渲染当前路由对应的组件
- 可在此添加全局布局（如导航栏、侧边栏等）

### 登录和注册组件

**Login.vue** 和 **Register.vue** 是相对简单的表单组件，负责：
- 用户输入验证
- API 调用
- Token 存储
- 页面跳转

这两个组件结构相似，都包含表单验证码校验和错误处理逻辑。

### 雷达展示组件 (`RadarView.vue`)

这是系统的核心组件，包含所有雷达数据展示和交互功能。组件采用 Vue 3 组合式 API，代码量约 2000 行。

#### 组件模板结构

组件模板分为以下几个主要区域：

**导航栏区域** (`header`):
- 显示标题和副标题
- 模式切换标签（拼图/单站）
- 当前雷达时间显示
- 用户信息和操作按钮（修改密码、退出）

**控制面板区域** (`control-panel`):
- 雷达类型选择（拼图/单站）
- 站点选择器（单站模式）：省份、城市、站点三级联动
- 时间范围选择器
- 图片缩放控制
- 数据刷新按钮

**拼图工具栏** (`mosaic-toolbar`):
- 区域选择下拉框（全国、华北、东北等）
- 时间范围选择器
- 缩放控制

**主视图区域** (`viewer-layout`):
- **左侧边栏**: 时间列表，显示所有可用时间点
- **中间区域**: 雷达图像展示容器
- **右侧边栏**: 快捷时间段选择（最近1-6小时）

**播放控制面板** (`modern-playback-panel`):
- 播放控制按钮组（开始、上一帧、播放/暂停、下一帧、结束）
- 当前时间显示
- 播放速度控制（加速/减速）
- 循环播放开关
- 时间轴滑块

#### 核心功能实现

##### 数据加载

**雷达拼图数据加载**:

```javascript
const loadRadarData = async (useCache = true, options = {}) => {
  loading.value = true
  try {
    const cacheKey = `radar-${region.value}-${dateRange.value ? 'range' : 'timeline'}`
    
    // 尝试从缓存加载
    if (useCache) {
      const cached = getCachedData(cacheKey)
      if (cached) {
        imageList.value = cached.images || []
        if (imageList.value.length > 0) {
          imageList.value.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
          currentIndex.value = imageList.value.length - 1
          loading.value = false
          return
        }
      }
    }

    // 根据时间范围或默认时间加载数据
    if (dateRange.value && dateRange.value.length === 2) {
      const [startLocal, endLocal] = dateRange.value
      const startISO = new Date(startLocal).toISOString()
      const endISO = new Date(endLocal).toISOString()
      
      // 限制时间范围不超过30天
      const daysDiff = Math.ceil((new Date(endLocal) - new Date(startLocal)) / (1000 * 60 * 60 * 24))
      if (daysDiff > 30) {
        ElMessage.warning(`选择的时间范围过长（${daysDiff}天），请选择30天以内的范围`)
        loading.value = false
        return
      }

      const resp = await getRadarByRange(startISO, endISO, region.value, null, null)
      imageList.value = (resp.images || []).map((img) => ({
        ...img,
        width: img.width || 0,
        height: img.height || 0
      }))
    } else {
      // 默认加载最近6小时数据
      const timeRange = await getTimeRange(region.value)
      if (timeRange.latest) {
        const latestTime = new Date(timeRange.latest)
        const startTime = new Date(latestTime.getTime() - 6 * 60 * 60 * 1000)
        const response = await getRadarByRange(
          startTime.toISOString(),
          latestTime.toISOString(),
          region.value,
          null,
          null
        )
        imageList.value = (response.images || []).map((img) => ({
          ...img,
          width: img.width || 0,
          height: img.height || 0
        }))
      }
    }

    // 排序并设置当前索引
    if (imageList.value.length > 0) {
      imageList.value.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
      currentIndex.value = imageList.value.length - 1
      cacheData(cacheKey, { images: imageList.value })
      preloadNearbyFrames(currentIndex.value).catch(() => {})
    }
  } catch (error) {
    console.error('Failed to load radar data:', error)
  } finally {
    loading.value = false
  }
}
```

**单站雷达数据加载**:

单站模式的数据加载逻辑类似，但增加了站点筛选和快速加载机制：
- 站点切换时先快速加载最新一张图片
- 后台异步加载完整数据
- 智能合并新旧数据

##### 图片预加载机制

**单张图片预加载**（带重试）:

```javascript
const preloadImage = (url, retryCount = 0) => {
  return new Promise((resolve, reject) => {
    // 检查缓存
    if (imageCache.value.has(url)) {
      resolve(imageCache.value.get(url))
      return
    }
    
    const img = new Image()
    img.onload = () => {
      imageCache.value.set(url, img)  // 存入缓存
      resolve(img)
    }
    img.onerror = (error) => {
      // 失败重试，最多重试2次
      if (retryCount < 2) {
        setTimeout(() => {
          preloadImage(url, retryCount + 1).then(resolve).catch(reject)
        }, 1000 * (retryCount + 1))
      } else {
        reject(error)
      }
    }
    img.src = url
  })
}
```

**智能预加载附近帧**:

```javascript
const preloadNearbyFrames = async (index) => {
  if (imageList.value.length === 0) return
  
  const totalImages = imageList.value.length
  let range, batchSize, delay
  
  // 根据数据量和播放状态动态调整策略
  if (isPlaying.value) {
    // 播放时：更大范围，更快速度
    if (totalImages > 10000) { range = 30; batchSize = 15; delay = 30 }
    else if (totalImages > 5000) { range = 40; batchSize = 20; delay = 25 }
    else { range = 60; batchSize = 30; delay = 15 }
  } else {
    // 暂停时：较小范围，较慢速度
    if (totalImages > 10000) { range = 30; batchSize = 8; delay = 100 }
    else if (totalImages > 5000) { range = 40; batchSize = 10; delay = 80 }
    else { range = 60; batchSize = 15; delay = 50 }
  }
  
  // 计算预加载范围
  const playMultiplier = isPlaying.value ? 3 : 1
  const effectiveRange = Math.min(range * playMultiplier, totalImages)
  const startIndex = Math.max(0, index - effectiveRange)
  const endIndex = Math.min(totalImages - 1, index + effectiveRange)
  
  // 分批加载，避免阻塞主线程
  for (let i = startIndex; i <= endIndex; i += batchSize) {
    const batchEnd = Math.min(i + batchSize - 1, endIndex)
    const batch = []
    for (let j = i; j <= batchEnd; j++) {
      if (imageList.value[j]?.url && !imageCache.value.has(imageList.value[j].url)) {
        batch.push(preloadImage(imageList.value[j].url).catch(() => {}))
      }
    }
    if (batch.length > 0) {
      await Promise.allSettled(batch)
      if (i + batchSize <= endIndex) {
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
  }
}

// 监听当前索引变化，自动预加载
watch(currentIndex, (newIndex) => {
  preloadNearbyFrames(newIndex)
})
```

##### 缓存机制

**数据缓存**（Map + localStorage）:

```javascript
const CACHE_TTL = 15 * 60 * 1000  // 15分钟
const dataCache = ref(new Map())

const cacheData = (key, data) => {
  const item = { data, timestamp: Date.now(), ttl: CACHE_TTL }
  dataCache.value.set(key, item)
  try {
    localStorage.setItem(`radar-cache-${key}`, JSON.stringify(item))
  } catch {}
}

const getCachedData = (key) => {
  // 先检查内存缓存
  if (dataCache.value.has(key)) {
    const item = dataCache.value.get(key)
    if (Date.now() - item.timestamp < item.ttl) return item.data
    dataCache.value.delete(key)
  }
  
  // 再检查 localStorage
  try {
    const stored = localStorage.getItem(`radar-cache-${key}`)
    if (stored) {
      const item = JSON.parse(stored)
      if (Date.now() - item.timestamp < item.ttl) {
        dataCache.value.set(key, item)
        return item.data
      } else {
        localStorage.removeItem(`radar-cache-${key}`)
      }
    }
  } catch {}
  return null
}
```

**图片缓存**:

使用 `Map` 存储已加载的图片对象，避免重复加载：

```javascript
const imageCache = ref(new Map())

// 在 preloadImage 中自动缓存
img.onload = () => {
  imageCache.value.set(url, img)
  resolve(img)
}
```

##### 播放控制

**自动播放实现**:

```javascript
const playInterval = ref(null)
const playbackIntervalMs = ref(100)  // 默认约10fps
const loopEnabled = ref(false)

const startAutoPlay = () => {
  isPlaying.value = true
  if (playInterval.value) {
    clearInterval(playInterval.value)
    playInterval.value = null
  }
  
  // 如果已到末尾，从头开始
  if (imageList.value.length > 0 && currentIndex.value >= imageList.value.length - 1) {
    currentIndex.value = 0
  }
  
  // 预加载附近帧
  preloadNearbyFrames(currentIndex.value).catch(() => {})
  
  // 播放定时器
  playInterval.value = setInterval(async () => {
    if (currentIndex.value < imageList.value.length - 1) {
      currentIndex.value++
      preloadNearbyFrames(currentIndex.value).catch(() => {})
    } else {
      if (loopEnabled.value && imageList.value.length > 0) {
        currentIndex.value = 0  // 循环播放
      } else {
        stopAutoPlay()
      }
    }
  }, playbackIntervalMs.value)
}

const stopAutoPlay = () => {
  isPlaying.value = false
  if (playInterval.value) {
    clearInterval(playInterval.value)
    playInterval.value = null
  }
}
```

**播放速度控制**:

```javascript
const decreaseSpeed = () => {
  playbackIntervalMs.value = Math.min(2000, playbackIntervalMs.value + 200)
  restartIfPlaying()
  ElMessage.info(`速度: ${(1000 / playbackIntervalMs.value).toFixed(1)} fps`)
}

const increaseSpeed = () => {
  playbackIntervalMs.value = Math.max(100, playbackIntervalMs.value - 100)
  restartIfPlaying()
  ElMessage.info(`速度: ${(1000 / playbackIntervalMs.value).toFixed(1)} fps`)
}
```

##### 响应式状态管理

使用 Vue 3 组合式 API 进行状态管理：

```javascript
import { ref, computed, watch } from 'vue'

export default {
  setup() {
    // 核心状态
    const imageList = ref([])
    const currentIndex = ref(0)
    const radarMode = ref('mosaic')
    const region = ref('NATIONAL')
    const selectedStation = ref('')
    const isPlaying = ref(false)
    const dateRange = ref(null)
    
    // 计算属性：自动从索引获取当前图像
    const currentImage = computed(() => {
      if (imageList.value.length === 0) return null
      return imageList.value[currentIndex.value]
    })
    
    // 计算属性：时间列表项
    const timeListItems = computed(() => {
      return imageList.value.map((item, index) => ({
        key: `${item.timestamp}-${index}`,
        index,
        timestamp: item.timestamp,
        display: formatTimestamp(item.timestamp)
      })).reverse()
    })
    
    return {
      imageList,
      currentIndex,
      currentImage,
      timeListItems,
      // ... 其他状态和方法
    }
  }
}
```

##### 性能优化技巧

**防抖处理**（站点/区域切换）:

```javascript
let stationChangeTimer = null

const scheduleStationChange = (nextStation) => {
  clearStationChangeTimer()
  cancelStationRequests()
  
  stationChangeTimer = setTimeout(() => {
    stationChangeTimer = null
    runStationChange(nextStation)
  }, 300)  // 300ms 防抖延迟
}
```

**请求取消**（使用 AbortController）:

```javascript
const activeStationController = ref(null)

const cancelStationRequests = () => {
  if (activeStationController.value) {
    activeStationController.value.abort()
    activeStationController.value = null
  }
}

const runStationChange = async (nextStation) => {
  const controller = new AbortController()
  activeStationController.value = controller
  
  try {
    await onStationChange(nextStation, requestId, controller)
  } catch (error) {
    if (!isAbortError(error)) console.error('站点切换失败:', error)
  }
}
```

### API 调用封装 (`api/radar.js`)

封装所有后端 API 调用，统一处理认证、错误和请求取消。

**Axios 实例配置**:

```javascript
import axios from 'axios'

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api'

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 60000,
  headers: {
    'Content-Type': 'application/json'
  }
})
```

**请求拦截器**（自动添加 Token）:

```javascript
apiClient.interceptors.request.use(
  config => {
    const token = localStorage.getItem('auth_token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => Promise.reject(error)
)
```

**响应拦截器**（Token 刷新）:

```javascript
apiClient.interceptors.response.use(
  response => response.data,
  async error => {
    // 401 错误时尝试刷新 Token
    const originalRequest = error.config
    if (error.response?.status === 401 && !originalRequest._retry) {
      const refreshToken = localStorage.getItem('refresh_token')
      if (refreshToken) {
        try {
          const resp = await axios.post(`${API_BASE_URL}/refresh`, { 
            refresh_token: refreshToken 
          })
          const newAccess = resp.data?.access_token
          localStorage.setItem('auth_token', newAccess)
          originalRequest.headers.Authorization = `Bearer ${newAccess}`
          return apiClient(originalRequest)
        } catch (refreshErr) {
          // 刷新失败，跳转登录
          localStorage.clear()
          window.location.reload()
        }
      }
    }
    return Promise.reject(error)
  }
)
```

**API 方法示例**:

```javascript
export const getRadarTimeline = (hours = 6, region) => {
  const params = { hours }
  if (region) params.region = region
  return apiClient.get('/radar/timeline', { params })
}

export const getRadarByRange = (startISO, endISO, region, page, pageSize, options = {}) => {
  const params = { start_time: startISO, end_time: endISO }
  if (region) params.region = region
  if (page) params.page = page
  if (pageSize) params.page_size = pageSize
  const config = { params }
  if (options.signal) config.signal = options.signal  // 支持请求取消
  return apiClient.get('/radar/list', config)
}
```

## 状态管理

使用 Vue 3 组合式 API 进行状态管理：

- **本地状态**: 使用 `ref` 和 `reactive`
- **计算属性**: 使用 `computed` 自动计算衍生状态
- **副作用**: 使用 `watch` 和 `watchEffect` 响应状态变化
- **生命周期**: 使用 `onMounted`、`onUnmounted` 处理组件生命周期

## 样式设计

使用 Scoped CSS 和现代 CSS 特性：

- **Flexbox 布局**: 实现响应式布局
- **CSS 变量**: 支持主题切换（可扩展）
- **过渡动画**: 平滑的状态切换效果
- **响应式设计**: 使用媒体查询适配不同屏幕尺寸

## 构建和部署

### 开发环境

```bash
npm install
npm run dev  # Vite 开发服务器，支持热更新
```

### 生产构建

```bash
npm run build  # 构建到 dist/ 目录
```

### Docker 构建

使用多阶段构建：
1. **构建阶段**: 安装依赖，使用 Vite 构建项目
2. **运行阶段**: 使用 Nginx 提供静态文件服务

## 浏览器兼容性

- 现代浏览器（Chrome、Firefox、Safari、Edge 最新版本）
- 支持 ES6+ 特性
- 需要支持 async/await
- 需要支持 Fetch API 或 Axios

## 性能指标

- **首屏加载**: < 2s（取决于网络和服务器）
- **图片预加载**: 智能分批加载，不阻塞主线程
- **播放流畅度**: 60fps（取决于数据量和设备性能）
- **内存使用**: 图片缓存自动限制，定期清理过期缓存

